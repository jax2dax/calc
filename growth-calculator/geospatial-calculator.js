 <![CDATA[ "use strict"; const geospatialCalculator = { calculateUnknownLocation(p1, r1, p2, r2, p3, r3) { if (!geospatialCalculator.validateCoordinates([p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]])) throw new Error('Invalid coordinates'); const [x1,y1]=p1; const [x2,y2]=p2; const [x3,y3]=p3; const dx=x2-x1; const dy=y2-y1; const distSq=dx**2+dy**2; const scale=(r1**2-r2**2+distSq)/(2*distSq); const ix=x1+scale*dx; const iy=y1+scale*dy; const d3=Math.hypot(ix-x3, iy-y3); return {x:ix,y:iy,dist:d3,description:d3<=r3?`Valid location (${d3.toFixed(2)}m from point 3)`:"Invalid location"}; }, validateCoordinates(coords) { return coords.every(c => typeof c==='number' && !Number.isNaN(c) && isFinite(c)); }, formatCoordinates(coords, precision=6) { return coords.map(c => parseFloat(c.toLocaleString('en-US', {minimumFractionDigits: precision}))); }, polygonArea(coords) { if(!geospatialCalculator.validateCoordinates(coords) || coords.length<3) return {error:"At least 3 valid coordinates required"}; let area=0; for(let i=0;i<coords.length;i++){ const x1=coords[i][0]; const y1=coords[i][1]; const x2=coords[(i+1)%coords.length][0]; const y2=coords[(i+1)%coords.length][1]; area+=x1*y2 - x2*y1; } return Math.abs(area/2); }, calculatePolygonPerimeter(coords) { if(!geospatialCalculator.validateCoordinates(coords) || coords.length<2) return {error:"At least 2 valid coordinates required"}; let total=0; for(let i=0;i<coords.length;i++){ const p1=coords[i]; const p2=coords[(i+1)%coords.length]; const R=6371000; const φ1=p1[1]*Math.PI/180; const φ2=p2[1]*Math.PI/180; const Δφ=(p2[1]-p1[1])*Math.PI/180; const Δλ=(p2[0]-p1[0])*Math.PI/180; const a=Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2; const c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)); total+=R*c; } return total; }, formatScale(value, units) { return { value: parseFloat(value.toFixed(2)), units: units; }; } }; export default geospatialCalculator; ]]>